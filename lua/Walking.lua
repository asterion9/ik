---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Steve.
--- DateTime: 30/11/2020 22:10
---

controller = nil

function Update(I)
    if controller == nil then
        controller = Controller.newAmplitudeController(I, buildArms(I))
    end
    controller:move(I)
end

function logSubConstructs(I, subConstructs)
    local comPos = I:GetConstructCenterOfMass()
    for i = 1, #subConstructs do
        local sc = I:GetSubConstructInfo(subConstructs[i])

        I:ClearLogs()
        I:Log(string.format(
                'subC %d, ' ..
                        'Position = %s, ' ..
                        'LocalPosition = %s, ' ..
                        'LocalPositionRelativeToCom = %s,' ..
                        'Forwards = %s, ' ..
                        'LocalForwards = %s, ' ..
                        'Rotation = %s,' ..
                        'LocalRotation = %s, ' ..
                        'Valid = %s, ' ..
                        'PositionRelativeToCom = %s',
                subConstructs[i],
                tostring(sc.Position), tostring(sc.LocalPosition), tostring(sc.LocalPositionRelativeToCom), tostring(sc.Forwards),
                tostring(sc.LocalForwards), tostring(sc.Rotation.eulerAngles), tostring(sc.LocalRotation.eulerAngles), tostring(sc.Valid),
                tostring(sc.Position - comPos)))
    end
end

function buildArms(I)
    --logSubConstructs(subConstructs)

    -- sprint strider
    --[[    legTemplate = {
            segments = {
                { len = Vector3(0, 0, 1), spinOffset = 0, spinDirection = -1 },
                { len = Vector3(0, 0, 16), spinOffset = 0, spinDirection = -1 },
                { len = Vector3(0, 0, 13.5), spinOffset = 0, spinDirection = -1 }
            }
        }]]

    -- monkeylord
    --[[    local rightSegment0 = { len = Vector3(0, 0, 16), spinOffset = 0, spinDirection = -1 }
        local leftSegment0 = { len = Vector3(0, 0, 16), spinOffset = 180, spinDirection = -1 }
        local segment1 = { len = Vector3(0, 0, 40), spinOffset = 0, spinDirection = 1 }
        local segment2 = { len = Vector3(0, 0, 70.4), spinOffset = 26.64, spinDirection = 1 }
        local rightLegSegments = { rightSegment0, segment1, segment2 }
        local leftLegSegments = { leftSegment0, segment1, segment2 }
        return PrefabLegBuilder.buildLegs(I, {
            { gaitCenter = Vector3(61.5, -37, -60), segments = rightLegSegments},  -- bottom right
            { gaitCenter = Vector3(83, -37, 0), segments = rightLegSegments},  -- middle right
            { gaitCenter = Vector3(43.5, -37, 65.3), segments = rightLegSegments},  -- top right
            { gaitCenter = Vector3(-43.5, -37, 65.3), segments = leftLegSegments},  -- top left
            { gaitCenter = Vector3(-83, -37, 0), segments = leftLegSegments},  -- middle left
            { gaitCenter = Vector3(-61.5, -37, -60), segments = leftLegSegments},  -- bottom left
        })]]
    -- ancient turret
    --[[ local segment0Right = { len = Vector3(0, 0, 4), spinOffset = 0, spinDirection = -1 }
    local segment0Left = { len = Vector3(0, 0, 4), spinOffset = 180, spinDirection = -1 }
    local segment1 = { len = Vector3(0, 0, 5), spinOffset = 0, spinDirection = 1 }
    local segment2 = { len = Vector3(0, 0, 5.5), spinOffset = 0, spinDirection = -1 }
    return PrefabLegBuilder.buildLegs(I,
            {
                { gaitCenter = Vector3(7, -3, -7), segments = { segment0Right, segment1, segment2 } }, -- bottom right
                { gaitCenter = Vector3(10, -3, 0), segments = { segment0Right, segment1, segment2 } }, -- middle right
                { gaitCenter = Vector3(7, -3, 7), segments = { segment0Right, segment1, segment2 } }, -- top right
                { gaitCenter = Vector3(-7, -3, 7), segments = { segment0Left, segment1, segment2 } }, -- top left
                { gaitCenter = Vector3(-10, -3, 0), segments = { segment0Left, segment1, segment2 } }, -- middle left
                { gaitCenter = Vector3(-7, -3, -7), segments = { segment0Left, segment1, segment2 } }  -- bottom left
            }) ]]

    --Bishop test 6 legs
    local segment0Right = { len = Vector3(0, 0, 4), spinOffset = 0, spinDirection = -1 }
    local segment0Left = { len = Vector3(0, 0, 4), spinOffset = 180, spinDirection = -1 }
    local segment1 = { len = Vector3(0, 0, 5), spinOffset = 0, spinDirection = -1 }
    local segment2 = { len = Vector3(0, 0, 5.5), spinOffset = 0, spinDirection = -1 }
    return PrefabLegBuilder.buildLegs(I,
            {
                { gaitCenter = Vector3(7, -3, -5), segments = { segment0Right, segment1, segment2 } }, -- bottom right
                { gaitCenter = Vector3(10, -3, 0), segments = { segment0Right, segment1, segment2 } }, -- middle right
                { gaitCenter = Vector3(7, -3, 5), segments = { segment0Right, segment1, segment2 } }, -- top right
                { gaitCenter = Vector3(-7, -3, 5), segments = { segment0Left, segment1, segment2 } }, -- top left
                { gaitCenter = Vector3(-10, -3, 0), segments = { segment0Left, segment1, segment2 } }, -- middle left
                { gaitCenter = Vector3(-7, -3, -5), segments = { segment0Left, segment1, segment2 } }  -- bottom left
            })


    -- small runner
    --[[    local segment0Right = { len = Vector3(0, 0, 9), spinOffset = 0, spinDirection = 1 }
        local segment0Left = { len = Vector3(0, 0, 9), spinOffset = 180, spinDirection = 1 }
        local segment1 = { len = Vector3(0, 0, 9), spinOffset = 0, spinDirection = -1 }
        local segment2 = { len = Vector3(0, 0, 9), spinOffset = 0, spinDirection = -1 }
        return PrefabLegBuilder.buildLegs(I,
                {
                    { gaitCenter = Vector3(12, -4, -12), segments = { segment0Right, segment1, segment2 } }, -- bottom right
                    { gaitCenter = Vector3(18, -4, 0), segments = { segment0Right, segment1, segment2 } }, -- middle right
                    { gaitCenter = Vector3(12, -4, 12), segments = { segment0Right, segment1, segment2 } }, -- top right
                    { gaitCenter = Vector3(-12, -4, 12), segments = { segment0Left, segment1, segment2 } }, -- top left
                    { gaitCenter = Vector3(-18, -4, 0), segments = { segment0Left, segment1, segment2 } }, -- middle left
                    { gaitCenter = Vector3(-12, -4, -12), segments = { segment0Left, segment1, segment2 } }  -- bottom left
                })]]
end

function rotateAround(base, yAngle, rotationCenter)
    local cosA = math.cos(yAngle)
    local sinA = math.sin(yAngle)
    return Vector3(
            rotationCenter.x + cosA * (base.x - rotationCenter.x) + sinA * (base.z - rotationCenter.z),
            base.y,
            rotationCenter.z - sinA * (base.x - rotationCenter.x) + cosA * (base.z - rotationCenter.z)
    )
end

--[[ Adjuster = {
    new = function(I, legs)
        return {
            comAdjust = Vector3.zero,
            maxOffset = legs[next(legs)].segments[2].len.z * 0.2,
            legOffsets = {},
            getForLeg = function(self, leg)
                local legOffset = self.legOffsets[leg]
                if (legOffset == nil) then
                    legOffset = Vector3.zero
                end
                return self.comAdjust + legOffset
            end,
            calculateLegOffsets = function(self, I, legTargets, t)
                local vehiculeWorldPosition = I:GetConstructCenterOfMass() + I:GetVelocityVector() * t
                --local vehiculeWorldRotation = Quaternion.LookRotation(I:GetConstructForwardVector(), I:GetConstructUpVector())
                local vehiculeWorldRotation = Quaternion.AngleAxis(I:GetConstructYaw(), Vector3.up)
                local n = 0
                local offset = 0
                self.legOffsets = {}
                for leg, target in pairs(legTargets) do
                    local targetLocalPosition = leg.position + target
                    local targetWorldPos = vehiculeWorldPosition + vehiculeWorldRotation * targetLocalPosition
                    local heightDiff = targetWorldPos.y - I:GetTerrainAltitudeForPosition(targetWorldPos.x, targetWorldPos.y, targetWorldPos.z)
                    self.legOffsets[leg] = heightDiff
                    offset = offset + heightDiff
                    n = n + 1
                end
                local meanOffset = offset / n
                local log = string.format("mean=%f, ", meanOffset)
                for leg, heightDiff in pairs(self.legOffsets) do
                    log = log .. string.format(" leg%d=%f ", leg.segments[1].spinId, heightDiff)
                end
                I:Log(log)
                for leg, heightDiff in pairs(self.legOffsets) do
                    local legOffset = heightDiff - meanOffset
                    if (math.abs(legOffset) > self.maxOffset) then
                        legOffset = self.maxOffset * legOffset / math.abs(legOffset)
                    end
                    self.legOffsets[leg] = Vector3(0, -legOffset, 0)
                end
            end
        }
    end
} ]]

Controller = {
    buildLegsGaits = function(I, legs)
        local legGaits = {}
        for id, leg in pairs(legs) do
            legGaits[leg] = {
                Walking = Gait.Walking.autoconfig(I, leg, -math.pi / 2),
                Strafing = Gait.Walking.autoconfig(I, leg, 0),
                Turning = Gait.Turning.autoconfig(I, leg),
                Resting = Gait.Resting.autoconfig(I, leg)
            }
        end
        return legGaits
    end,
    calculateTarget = function(leg, gaits, curStep, forward, yaw, strafe)
        local fTarget
        local sTarget
        local yTarget
        local rTarget = gaits['Resting'].getPoint((curStep + leg.phase) % 1)
        local fRatio = math.abs(forward)
        local sRatio = math.abs(strafe)
        local yRatio = math.abs(yaw)
        local fDirection = Mathf.Sign(forward)
        local sDirection = Mathf.Sign(strafe)
        local yDirection = Mathf.Sign(yaw)
        if (fRatio > 0.01) then
            fTarget = (fRatio * gaits['Walking'].getPoint((fDirection * (curStep + leg.phase) % 1)) + (1 - fRatio) * rTarget)
        end
        if (sRatio > 0.01) then
            sTarget = (sRatio * gaits['Strafing'].getPoint((sDirection * (curStep + leg.phase) % 1)) + (1 - sRatio) * rTarget)
        end
        if (yRatio > 0.01) then
            yTarget = (yRatio * gaits['Turning'].getPoint((yDirection * (curStep + leg.phase) % 1)) + (1 - yRatio) * rTarget)
        end

        local wTarget = nil
        if (fTarget ~= nil) then
            if (sTarget ~= nil) then
                wTarget = fTarget + sTarget - leg.gaitCenter
            else
                wTarget = fTarget
            end
        elseif sTarget ~= nil then
            wTarget = sTarget
        end

        if (wTarget ~= nil) then
            if (yTarget ~= nil) then
                return (wTarget + yTarget) / 2
            else
                return wTarget
            end
        elseif yTarget ~= nil then
            return yTarget
        else
            return rTarget
        end
    end,
    newAmplitudeController = function(I, legs)
        local legGaits = Controller.buildLegsGaits(I, legs)
        return {
            legGaits = legGaits,
            cps = 1, -- cycles per second
            --comAdjuster = Adjuster.new(I, legs),
            lastTime = I:GetGameTime(),
            curTurn = 0,
            commandReader = InputReader.new(I),
            move = function(self, I)
                local curTime = I:GetGameTime()
                local curStep = (curTime * self.cps) % 1
                local inputs = self.commandReader:getCommands(I)
                I:Log(string.format('forward=%f, yaw=%f, strafe=%f', inputs.forward, inputs.yaw, inputs.strafe))
                local legTargets = {}
                for leg, gaits in pairs(self.legGaits) do
                    local target = Controller.calculateTarget(leg, gaits, curStep, inputs.forward, inputs.yaw, inputs.strafe)
                    legTargets[leg] = target
                end
                --self.comAdjuster:calculateLegOffsets(I, legTargets, curTime - self.lastTime)
                for leg, target in pairs(legTargets) do
                    --leg:moveLeg(I, target + self.comAdjuster:getForLeg(leg), curTime)
                    leg:moveLeg(I, target, curTime)
                end
                self.lastTime = curTime
            end,
            checkIntegrity = function(self, I)
                local subConstructs = I:GetAllSubConstructs()
                local scIndex = {}
                for i = 1, #subConstructs do
                    scIndex[subConstructs[i]] = true
                end
                for leg, gaits in pairs(self.legGaits) do
                    if not scIndex[leg.segments[1].spinId] then
                        return false
                    end
                end
                return true
            end
        }
    end
}

Smoother = {
    new = function()
        return {
            target = 0,
            speed = 0.05,
            value = 0,
            update = function(self, val)
                self.target = val
                return self
            end,
            evaluate = function(self)
                if (self.target ~= self.value) then
                    if (math.abs(self.target - self.value) < self.speed) then
                        self.value = self.target
                    else
                        local sign = Mathf.Sign(self.target - self.value)
                        self.value = self.value + sign * self.speed
                    end
                end
                return self.value
            end
        }
    end
}

InputReader = {
    new = function(I)
        local strafeId = -1
        local forwardId = -1
        local subConstructs = I:GetAllSubConstructs()
        for i = 1, #subConstructs do
            if I:IsSpinBlock(subConstructs[i]) then
                if I:IsSubConstructOnHull(subConstructs[i]) then
                    local blockInfo = I:GetSubConstructInfo(subConstructs[i])
                    if blockInfo.CustomName == "strafer" then
                        strafeId = blockInfo.SubConstructIdentifier
                    elseif blockInfo.CustomName == "forwarder" then
                        forwardId = blockInfo.SubConstructIdentifier
                    end
                end
            end
        end

        local commands = {
            forward = {
                forwardId = forwardId,
                smoother = Smoother.new(),
                read = function(self, I)
                    local drive = I:GetDrive(0)
                    if drive == 0 then
                        return InputReader.readSpinner(I, self.forwardId)
                    else
                        return drive
                    end
                end
            },
            yaw = {
                smoother = Smoother.new(),
                read = function(self, I)
                    return I:GetInput(0, 0) - I:GetInput(0, 1)
                end
            },
            strafe = {
                strafeId = strafeId,
                smoother = Smoother.new(),
                read = function(self, I)
                    return InputReader.readSpinner(I, self.strafeId)
                end
            }
        }

        return {
            commands = commands,
            getCommands = function(self, I)
                return {
                    forward = self.commands.forward.smoother:update(self.commands.forward:read(I)):evaluate(),
                    strafe = self.commands.strafe.smoother:update(self.commands.strafe:read(I)):evaluate(),
                    yaw = self.commands.yaw.smoother:update(self.commands.yaw:read(I)):evaluate(),
                }
            end
        }
    end,
    readSpinner = function(I, spinnerId)
        if spinnerId ~= -1 then
            local angle = Vector3.SignedAngle(Vector3.forward, I:GetSubConstructInfo(spinnerId).LocalForwards, Vector3.up)
            return angle / 90
        end
        return 0
    end
}

Gait = {
    Walking = {
        new = function(position, yAngle, height, width)
            return {
                getPoint = function(t)
                    local groundRatio = 0.7
                    t = (t + groundRatio / 2) % 1
                    local target
                    if (t < groundRatio) then
                        target = Vector3(
                                position.x + width / 2 - (t / groundRatio) * width,
                                position.y,
                                position.z)
                    else
                        local te = 0.5 - 0.5 * (t - groundRatio) / (1 - groundRatio)
                        target = Vector3(
                                position.x + math.cos(te * math.pi * 2) * (width / 2),
                                position.y + math.sin(te * math.pi * 2) * height,
                                position.z)
                    end
                    return rotateAround(target, yAngle, position)
                end
            }
        end,
        autoconfig = function(I, leg, angle)
            local position
            if leg.gaitCenter == nil then
                local legDirection = I:GetSubConstructInfo(leg.segments[1].spinId).LocalPositionRelativeToCom
                position = legDirection.normalized * ((leg.segments[1].len.z + leg.segments[2].len.z) * 1.2)
                position.y = -leg.segments[3].len.z + leg.segments[1].len.y - 2
            else
                position = leg.gaitCenter
            end

            I:Log(string.format("creating walking gait for leg %s, centered at %s with width %f", tostring(leg.position), tostring(position), leg.segments[3].len.z * 1.2))

            return Gait.Walking.new(position,
                    angle, math.max(leg.segments[3].len.z * 0.5, 3), math.sqrt(position.x * position.x + position.z * position.z))
        end
    },
    Turning = {
        new = function(center, radius, radStart, radLength, height)
            return {
                getPoint = function(t)
                    local groundRatio = 0.7
                    t = (t + groundRatio / 2) % 1
                    if (t < groundRatio) then
                        -- foot on ground
                        local tg = t / groundRatio
                        return Vector3(
                                center.x + radius * math.cos(radStart + (radLength * (tg))),
                                center.y,
                                center.z + radius * math.sin(radStart + (radLength * (tg))))
                    else
                        local tv = 0.5 * (t - groundRatio) / (1 - groundRatio)
                        local th = (1 + math.cos(tv * math.pi * 2)) / 2;
                        return Vector3(
                                center.x + radius * math.cos(radStart + (radLength * th)),
                                center.y + math.sin(tv * math.pi * 2) * height,
                                center.z + radius * math.sin(radStart + (radLength * th)));
                    end
                end
            }
        end,
        autoconfig = function(I, leg)
            local spinPosition = I:GetSubConstructInfo(leg.segments[1].spinId).LocalPositionRelativeToCom

            local rotCenter
            local rotRadius
            local angleOffset
            if leg.gaitCenter == nil then
                rotCenter = Vector3(-spinPosition.x, -leg.segments[3].len.z + leg.segments[1].len.y - 2, -spinPosition.z)
                rotRadius = math.sqrt(spinPosition.x * spinPosition.x + spinPosition.z * spinPosition.z) + leg.segments[1].len.z + leg.segments[2].len.z
                angleOffset = 2 * math.pi * Vector3.SignedAngle(Vector3.ProjectOnPlane(spinPosition, Vector3.up), Vector3.right, Vector3.up) / 360
            else
                rotCenter = Vector3(-spinPosition.x, leg.gaitCenter.y, -spinPosition.z)
                rotRadius = Vector3.Distance(rotCenter, leg.gaitCenter)
                angleOffset = 2 * math.pi * Vector3.SignedAngle(Vector3.ProjectOnPlane(leg.gaitCenter, Vector3.up), Vector3.right, Vector3.up) / 360
            end

            I:Log(string.format("creating turning gait for leg %s, rotating around %s with radius %f and direction %f", tostring(leg.position), tostring(rotCenter), rotRadius, angleOffset))

            return Gait.Turning.new(rotCenter,
                    rotRadius,
                    angleOffset + math.pi / 12,
                    -math.pi / 6,
                    math.max(leg.segments[3].len.z * 0.5, 3)
            )
        end
    },
    Resting = {
        new = function(position)
            return {
                getPoint = function(t)
                    return position
                end
            }
        end,
        autoconfig = function(I, leg)
            local position
            if leg.gaitCenter == nil then
                local legDirection = I:GetSubConstructInfo(leg.segments[1].spinId).LocalPositionRelativeToCom
                position = legDirection.normalized * ((leg.segments[1].len.z + leg.segments[2].len.z) * 1.2)
                position.y = -leg.segments[3].len.z + leg.segments[1].len.y - 2
            else
                position = leg.gaitCenter
            end
            I:Log(string.format("creating resting gait for leg %s, at %s", tostring(leg.position), tostring(position)))
            return Gait.Resting.new(position)
        end
    }
}

Segment = {
    new = function(spinId, len, spinOffset, spinDirection)
        return {
            lastUpdate = nil,
            lastAngle = nil,
            spinId = spinId,
            len = len,
            spinOffset = spinOffset,
            spinDirection = spinDirection,
            setAngle = function(self, I, angle, t)
                local rotSpeed = 0
                if (self.lastUpdate ~= nil and self.lastUpdate ~= t) then
                    local ellapsedTime = (t - self.lastUpdate + 1) % 1
                    rotSpeed = math.min(math.abs((angle - self.lastAngle) / (ellapsedTime)), 30)
                    --I:Log(string.format('spiner %d going from %f to %f in %f seconds, setting speed at %f rad/s', self.spinId, self.lastAngle, angle, ellapsedTime, rotSpeed))
                end
                self.lastUpdate = t
                self.lastAngle = angle
                I:SetSpinBlockContinuousSpeed(self.spinId, 30)
                local angleDeg = 360 * angle / (2 * math.pi)
                I:SetSpinBlockRotationAngle(self.spinId, self.spinDirection * (angleDeg + self.spinOffset))
            end
        }
    end
}

PrefabLegBuilder = {
    buildLegs = function(I, legTemplates)
        local subConstructs = I:GetAllSubConstructs()

        local scByOrientation = {}
        for i = 1, #subConstructs do
            local id = subConstructs[i]
            if I:IsSpinBlock(id) then
                if I:IsSubConstructOnHull(id) then
                    local scPos = I:GetSubConstructInfo(id).LocalPositionRelativeToCom
                    table.insert(scByOrientation, { id = id, ori = Vector3.SignedAngle(Vector3.forward, Vector3.ProjectOnPlane(scPos, Vector3.up), Vector3.up) })
                end
            end
        end
        table.sort(scByOrientation, function(a, b)
            return a.ori > b.ori
        end)

        local legs = {}
        local i = 1
        local defaultPhase = 0
        for pos, scSorted in pairs(scByOrientation) do
            local scId = scSorted.id
            if legTemplates[i] ~= nil then
                local leg = PrefabLegBuilder.buildLegFromTemplate(I, scId, legTemplates[i])
                if leg ~= nil then
                    if (legTemplates[i].phase == nil) then
                        leg.phase = defaultPhase
                    else
                        leg.phase = legTemplates[i].phase
                    end
                    defaultPhase = (defaultPhase + 0.5) % 1
                    legs[scId] = leg
                    i = i + 1
                    I:Log(string.format('built leg : position %s, gaitCenter %s, segment length %f', tostring(leg.position), tostring(leg.gaitCenter), leg.length))
                end
            end
        end

        return legs
    end,
    buildLegFromTemplate = function(I, baseScId, legTemplate)
        local sc = I:GetSubConstructInfo(baseScId)
        local length = 0
        for i = 1, #legTemplate.segments do
            length = length + legTemplate.segments[i].len.magnitude
        end
        local leg = {
            position = sc.LocalPositionRelativeToCom,
            segments = {},
            moveLeg = IkLib.move3SegmentsLeg,
            gaitCenter = legTemplate.gaitCenter,
            length = length
        }

        I:Log(string.format('found base spinner number %d', sc.SubConstructIdentifier))
        for i = 1, #legTemplate.segments do
            local segTemplate = legTemplate.segments[i]
            leg.segments[i] = Segment.new(
                    sc.SubConstructIdentifier,
                    segTemplate.len,
                    segTemplate.spinOffset,
                    segTemplate.spinDirection
            )

            if i < #legTemplate.segments then
                local scChildren = I:GetAllSubConstructChildren(sc.SubConstructIdentifier)
                if (#scChildren ~= 1) then
                    I:Log("not a leg, keeping searching")
                    return nil
                else
                    sc = I:GetSubConstructInfo(scChildren[1])
                end
            end
        end
        return leg
    end
}

IkLib = {
    move3SegmentsLeg = function(leg, I, target, t)
        if target.magnitude > leg.length then
            I:LogToHud(string.format("ERROR : target %s is too far for leg %s !", tostring(target), leg.segments[1].spinId))
        end

        if target.magnitude < leg.segments[1].len.z then
            I:LogToHud(string.format("ERROR : target %s is too close for leg %s !", tostring(target), leg.segments[1].spinId))
        end

        local a0 = (target.z > 0 and -1 or 1) * math.acos(target.x / math.sqrt(target.x * target.x + target.z * target.z))

        local rx = target.x / math.cos(a0) - leg.segments[1].len.z
        local ry = target.y
        local rMag = math.sqrt(rx * rx + ry * ry)

        local a1 = (ry > 0 and 1 or -1) * math.acos(rx / rMag)
                + math.acos(
                (leg.segments[2].len.z * leg.segments[2].len.z + rMag * rMag - leg.segments[3].len.z * leg.segments[3].len.z)
                        / (2 * leg.segments[2].len.z * rMag))

        local a2 = -math.acos((rMag * rMag - leg.segments[2].len.z * leg.segments[2].len.z - leg.segments[3].len.z * leg.segments[3].len.z)
                / (2 * leg.segments[2].len.z * leg.segments[3].len.z))

        I:Log(string.format('t=%f : moving leg %d at %s, offset=%d, spinDir=%d to %s with angle a0=%f, a1=%f, a2=%f',
                t, leg.segments[1].spinId, tostring(leg.position), leg.segments[1].spinOffset, leg.segments[1].spinDirection, tostring(target), a0, a1, a2))

        leg.segments[1]:setAngle(I, a0, t)
        leg.segments[2]:setAngle(I, a1, t)
        leg.segments[3]:setAngle(I, a2, t)
    end
}